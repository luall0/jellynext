# CLAUDE.md

## Purpose
This file serves as the persistent memory and context store for Claude Code instances working on this repository. It contains critical information about the codebase structure, patterns, conventions, and decisions that must be maintained across sessions.

## How to Update This File

### When to Update
- After implementing new architectural patterns or conventions
- When adding new major features or modules
- After making important technical decisions
- When establishing new coding standards
- After refactoring that changes core structure
- When discovering critical dependencies or constraints

### What to Include
- **Architecture decisions**: Why certain patterns were chosen
- **Code conventions**: Naming, structure, style specific to this project
- **Key abstractions**: Core interfaces, base classes, shared utilities
- **Critical paths**: Authentication, data flow, state management
- **Gotchas**: Non-obvious behaviors, edge cases, pitfalls to avoid
- **Dependencies**: Important libraries and their usage patterns
- **Test strategies**: How to test different parts of the system

### What NOT to Include
- Implementation details that are clear from code
- Temporary TODOs (use code comments instead)
- Change logs (use git history)
- API documentation (use code docs/comments)
- General programming knowledge
- **Test counts or execution times** (these change frequently and provide no useful context)
- **Build commands and scripts** - These live in package.json. Only document non-obvious usage patterns.
- **Metadata footers** - No "Last Updated" dates (use git), version numbers (use package.json), or feature summaries (redundant with content)

### Update Format
Keep updates concise and scannable. Use clear section headers. Focus on context that helps make better decisions faster.

**Balance conciseness with clarity**:
- Prefer bullet points over paragraphs
- Remove obvious information, but keep context that explains "why"
- Show code examples when they clarify non-obvious patterns
- Aim for information density, but prioritize understandability over brevity
- **Keep file/test organization trees** - they help navigate the codebase
- **Keep method signatures and parameters** - they document the API surface
- **Allow some duplication** when it helps understanding (e.g., listing capabilities in overview + detailed sections)

### Git Commit Rules
**NEVER use co-authoring in git commits.** Always commit as the sole author. Do not add "Co-authored-by" trailers to commit messages under any circumstances.

**NEVER add "Generated by Claude Code" or similar attribution** to commit messages. Commit messages should describe the change only, without mentioning AI assistance.

### Code Documentation Rules
**Do not over-document.** Only add comments for:
- Non-obvious business logic or algorithms
- Complex edge cases or gotchas
- Why decisions were made (not what the code does)

Avoid documenting:
- Obvious functionality that's clear from well-named functions/variables
- Redundant type information already in signatures
- What standard library functions do
- Implementation details that are self-explanatory

Good code with clear naming is better than heavily commented code.

**Do not create separate documentation files for features.** Keep documentation minimal and centralized:
- Feature descriptions belong in README.md, kept concise
- Do NOT create individual .md files for each feature or module
- Code should be self-documenting through clear naming and structure
- Only create additional docs if absolutely necessary for complex systems

Avoid documentation sprawl. Less is more.

### Testing and Token Optimization
**IMPORTANT - Token Efficiency**: When running full test suite to verify no breakage, ALWAYS filter output to show only summary:
NEVER run full test output without filtering - console logs consume thousands of tokens unnecessarily.

---

## Project Overview

JellyNext is a Jellyfin plugin that integrates Trakt-powered discovery directly into Jellyfin. It creates per-user virtual libraries for personalized recommendations and new season notifications, with one-click download triggers to Radarr/Sonarr.

**Core capabilities:**
- Per-user Trakt account linking (each Jellyfin user links their own Trakt)
- Virtual libraries: Recommendations and New Seasons (personalized per user)
- One-click downloads via Radarr/Sonarr integration
- Smart Play/Download button switching (shows Play if media exists, Download if not)
- Metadata enrichment via TMDB

## Tech Stack

- **Platform**: C# / .NET 8.0
- **Framework**: Jellyfin Plugin SDK 10.9+
- **External APIs**:
  - Trakt API (OAuth2 for per-user auth)
  - TMDB API (metadata & images)
  - Radarr/Sonarr APIs (download triggers)
- **Code Quality**: StyleCop.Analyzers + jellyfin.ruleset

## Architecture

### Project Structure
```
Jellyfin.Plugin.JellyNext/
├── Configuration/
│   ├── PluginConfiguration.cs   # Global plugin settings
│   └── configPage.html           # Admin web UI (OAuth + config)
├── Api/
│   └── TraktController.cs        # OAuth endpoints
├── Services/
│   ├── TraktApi.cs               # Trakt API integration
│   ├── TmdbService.cs            # TMDB API key management (custom or Jellyfin's)
│   ├── ContentCacheService.cs    # In-memory cache for synced content
│   └── ContentSyncService.cs     # Orchestrates syncing across providers
├── Providers/
│   ├── IContentProvider.cs       # Interface for content providers
│   └── RecommendationsProvider.cs # Trakt recommendations implementation
├── ScheduledTasks/
│   └── ContentSyncScheduledTask.cs # Jellyfin scheduled task for syncing
├── Models/
│   ├── TraktUser.cs              # Per-user OAuth storage
│   ├── TraktDeviceCode.cs        # OAuth device flow
│   ├── TraktUserAccessToken.cs   # OAuth tokens
│   ├── TraktUserRefreshTokenRequest.cs
│   ├── TraktMovie.cs             # Trakt movie response
│   ├── TraktShow.cs              # Trakt show response
│   ├── TraktIds.cs               # External IDs (TMDB, IMDB, TVDB, etc)
│   ├── ContentItem.cs            # Unified content representation
│   └── ContentType.cs            # Movie/Show enum
├── Helpers/
│   └── UserHelper.cs             # TraktUser lookup utility
├── Plugin.cs                     # Entry point + IServerApplicationHost
└── PluginServiceRegistrator.cs  # DI service registration
```

### Key Plugin Components
- **Plugin.cs**: Main entry point, inherits `BasePlugin<PluginConfiguration>`, tracks OAuth polling tasks, exposes `IServerApplicationHost`
- **PluginConfiguration**: Stores global settings (Radarr/Sonarr URLs/keys, optional TMDB key, cache expiration, ignore filters, per-user TraktUser array)
- **PluginServiceRegistrator**: Registers all services and content providers in DI container
- **TraktController**: REST endpoints for OAuth (authorize, deauthorize, status check)
- **TraktApi**: Handles OAuth device flow, token refresh, authenticated API calls, recommendations fetching
- **TmdbService**: Manages TMDB API key (uses custom if provided, falls back to Jellyfin's via reflection)
- **ContentCacheService**: In-memory per-user, per-provider cache with automatic expiration
- **ContentSyncService**: Orchestrates syncing across all registered `IContentProvider` implementations
- **IContentProvider**: Modular interface for content sources (recommendations, watchlist, trending, etc.)
- **ContentSyncScheduledTask**: Jellyfin scheduled task (configurable in Dashboard)

## Key Conventions

### Jellyfin Plugin Standards
- Follow `jellyfin.ruleset` for code analysis (enforced via StyleCop.Analyzers)
- Use XML documentation for public APIs (GenerateDocumentationFile enabled)
- Enable nullable reference types
- Embed web resources (HTML/JS) into assembly

### HTTP Client Usage
- **ALWAYS use `NamedClient.Default`** when creating HTTP clients: `_httpClientFactory.CreateClient(NamedClient.Default)`
- This uses Jellyfin's preconfigured "happy eyeballs" HTTP client
- Required for Trakt API to work (avoids Cloudflare blocks)
- `NamedClient` from `MediaBrowser.Common.Net` namespace

### Trakt API Headers
- **Only two headers required**: `trakt-api-version: 2` and `trakt-api-key: {client_id}`
- Do NOT add User-Agent or Accept headers (causes issues)
- Base URL: `https://api.trakt.tv`
- Endpoints: `/oauth/device/code`, `/oauth/device/token`, `/oauth/token`

### Dependency Injection
- Register services in `PluginServiceRegistrator.cs` implementing `IPluginServiceRegistrator`
- Must register `AddHttpClient()` before services that use `IHttpClientFactory`
- Services auto-discovered by Jellyfin on plugin load
- Content providers registered as `IContentProvider` interface - automatically discovered by `ContentSyncService`

### Per-User Architecture Pattern
- Virtual libraries must be **filtered by current Jellyfin user**
- Each user has their own Trakt OAuth token (stored per-user, not global)
- Item resolution checks user context to return personalized content
- Download triggers use global Radarr/Sonarr credentials but are initiated per-user

### Smart Play/Download Switching
- Before returning virtual item: check if media exists in Jellyfin by TMDB/TVDB ID
- If exists: return real Jellyfin item ID → shows native Play button
- If not exists: return virtual item with `plugin://jellynext/download/{id}` → triggers download on Play
- Works cross-client (Web, iOS, Android, TV, Kodi) via playback interception

## Important Constraints

### Jellyfin Plugin Limitations
- No native "Download" button in clients → use playback interception workaround
- Virtual items must implement proper metadata interfaces to appear correctly
- Embedded resources (HTML/JS) require specific .csproj configuration
- Plugin GUID must be unique and stable: `a4df60c5-6ab4-412a-8f79-2cab93fb2bc5`

### API Rate Limits
- Trakt: respect rate limits (implement caching + scheduled sync)
- TMDB: cache metadata aggressively
- Radarr/Sonarr: minimal calls (only on user-triggered downloads)

### Cross-Client Compatibility
- Must work on all official Jellyfin clients (Web, iOS, Android, TV, Kodi)
- Cannot rely on Web UI-only features for core functionality
- Optional: Web UI JavaScript injection for enhanced UX

### Modular Content Provider System
- **IContentProvider interface**: Extensible contract for content sources
  - `ProviderName`: Unique identifier (e.g., "recommendations", "watchlist")
  - `LibraryName`: Display name for virtual library
  - `FetchContentAsync(userId)`: Fetches content for specific user
  - `IsEnabledForUser(userId)`: Checks if provider enabled for user
- **Easy to add new providers**: Create class implementing `IContentProvider`, register in DI → automatic sync/caching
- **ContentItem model**: Unified representation (movies + shows, all external IDs)
- **ContentSyncService**: Orchestrates syncing across all providers with error isolation
- **ContentCacheService**: Per-user, per-provider in-memory cache with configurable expiration

### TMDB API Key Management
- **Optional configuration**: Users can provide custom TMDB API key (free at themoviedb.org)
- **Automatic fallback**: If no key provided, uses Jellyfin's built-in TMDB key via reflection
- **Benefits of custom key**: Dedicated rate limits, avoids high-traffic metadata issues
- **TmdbService.GetTmdbApiKey()**: Handles custom key priority + reflection fallback with caching

## Implemented Features

### ✅ Per-User Trakt OAuth (Device Flow)
**Architecture:**
- Trakt Client ID/Secret embedded in `TraktApi.cs` (not in config)
- Per-user OAuth tokens stored in `PluginConfiguration.TraktUsers[]` array
- Each `TraktUser` has: `AccessToken`, `RefreshToken`, `LinkedMbUserId`, `AccessTokenExpiration`

**OAuth Device Flow:**
1. Admin selects Jellyfin user in plugin config page
2. Click "Link Trakt Account" → `POST /JellyNext/Trakt/Users/{userGuid}/Authorize`
3. Backend requests device code from Trakt API
4. Frontend displays user code + trakt.tv/activate link
5. Background polling task checks authorization every 3 seconds
6. On success: stores access/refresh tokens in `TraktUser`, saves config
7. Frontend auto-detects completion and shows success

**Automatic Token Refresh:**
- Tokens expire with 75% safety buffer (`ExpirationWithBuffer`)
- `EnsureValidAccessToken()` checks expiration before every API call
- `RefreshUserAccessToken()` exchanges refresh token for new access token
- Trakt rotates refresh tokens on each refresh (new tokens saved automatically)

**Key Methods:**
- `TraktApi.AuthorizeDevice(traktUser)` - Initiates device flow
- `TraktApi.PollForAccessToken(deviceCode, traktUser)` - Background polling
- `TraktApi.RefreshUserAccessToken(traktUser)` - Token refresh
- `TraktApi.CreateTraktClient(traktUser)` - Creates authenticated HTTP client with auto-refresh
- `UserHelper.GetTraktUser(userGuid)` - Lookup TraktUser by Jellyfin user ID

**API Endpoints:**
- `POST /JellyNext/Trakt/Users/{userGuid}/Authorize` - Start OAuth
- `GET /JellyNext/Trakt/Users/{userGuid}/AuthorizationStatus` - Check status
- `POST /JellyNext/Trakt/Users/{userGuid}/Deauthorize` - Revoke access

### ✅ Trakt Recommendations API
**Endpoints:**
- `TraktApi.GetMovieRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized movie recommendations
- `TraktApi.GetShowRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized show recommendations

**Configuration:**
- `IgnoreCollected` (default: true) - Filter out items in user's Trakt collection
- `IgnoreWatchlisted` (default: false) - Filter out items in user's watchlist
- Both configurable via plugin settings page

**Implementation:**
- Returns `TraktMovie[]` and `TraktShow[]` with IDs (Trakt, TMDB, IMDB, TVDB)
- Automatic token refresh before API calls
- Error handling with empty array fallback

### ✅ Modular Content Sync System
**Architecture:**
- `ContentSyncScheduledTask` - Jellyfin scheduled task (appears in Dashboard → Scheduled Tasks)
- Default trigger: every 6 hours (user-configurable in Dashboard)
- `ContentSyncService.SyncAllAsync()` - Syncs all users across all registered providers
- Per-provider error isolation - one failure doesn't break entire sync

**Caching:**
- `ContentCacheService` - In-memory cache per user per provider
- `CacheExpirationHours` config (default: 6 hours) - Controls data freshness
- Cache serves instant results for virtual library browsing
- Protects against Trakt API rate limits

**Current Providers:**
- `RecommendationsProvider` - Fetches movie + show recommendations (up to 50 each)

## Core Workflows

### Initial Setup (Admin)
1. Admin configures plugin via Jellyfin Dashboard
2. (Optional) Enter custom TMDB API key (uses Jellyfin's key if not provided)
3. Enter Radarr/Sonarr URLs + API keys
4. Configure recommendation filters (ignore collected/watchlisted)
5. Set cache expiration (default: 6 hours)
6. Configure sync schedule in Dashboard → Scheduled Tasks → "Sync Trakt Content"

### User Trakt Linking (Per-User)
1. Admin opens plugin config → selects Jellyfin user from dropdown
2. Clicks "Link Trakt Account" → receives user code
3. User visits trakt.tv/activate and enters code
4. Plugin auto-detects authorization completion
5. Tokens stored in `PluginConfiguration.TraktUsers[]` for that user

### Virtual Library Display
1. User opens "Trakt Recommendations" or "New Seasons" library
2. Plugin fetches user's Trakt data (cached)
3. For each item: check if exists in Jellyfin by TMDB ID
4. Return existing item ID (Play) or virtual item (Download)
5. Enrich with TMDB metadata (poster, description)

### Download Trigger
1. User clicks Play on virtual item with `plugin://` path
2. Plugin intercepts playback request
3. Parse TMDB ID from URL
4. Call Radarr/Sonarr API to add media
5. Show notification to user (download initiated)

## Important Gotchas

### Trakt API OAuth
- **Cloudflare Protection**: Trakt API is behind Cloudflare - must use `NamedClient.Default` HTTP client
- **No Custom Headers**: Only use `trakt-api-version` and `trakt-api-key` headers (User-Agent/Accept cause blocks)
- **Token Safety Buffer**: Use 75% of token lifetime before refresh to prevent race conditions
- **Refresh Token Rotation**: Trakt rotates refresh tokens on each refresh - always save new tokens
- **Background Polling**: OAuth device flow polls in background - track with `Plugin.Instance.PollingTasks` dictionary

### Configuration Access
- Use `Plugin.Instance?.Configuration` not `Plugin.Instance?.PluginConfiguration`
- `BasePlugin<T>` exposes config as `Configuration` property
- `UserHelper.GetTraktUser(userGuid)` is the standard way to lookup per-user tokens

### TMDB API Key Access
- **TmdbService** handles TMDB API key with intelligent fallback
- Custom key from config is prioritized
- Fallback uses reflection to access Jellyfin's TMDB plugin configuration
- Reflection path: `IServerApplicationHost` → `PluginManager` → `TmdbPlugin` → `Configuration.TmdbApiKey`
- Cached after first reflection lookup for performance

### Content Sync Architecture
- **Scheduled task** (`ContentSyncScheduledTask`) registered with Jellyfin's task manager
- `GetDefaultTriggers()` sets initial 6-hour interval (user can change in Dashboard)
- **Cache expiration** is separate from sync schedule (prevents indefinitely stale data)
- Cache serves instant responses when browsing virtual libraries
- Sync refreshes cache on schedule or manual trigger

---