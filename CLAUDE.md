# CLAUDE.md

## Purpose
This file serves as the persistent memory and context store for Claude Code instances working on this repository. It contains critical information about the codebase structure, patterns, conventions, and decisions that must be maintained across sessions.

## How to Update This File

### When to Update
- After implementing new architectural patterns or conventions
- When adding new major features or modules
- After making important technical decisions
- When establishing new coding standards
- After refactoring that changes core structure
- When discovering critical dependencies or constraints

### What to Include
- **Architecture decisions**: Why certain patterns were chosen
- **Code conventions**: Naming, structure, style specific to this project
- **Key abstractions**: Core interfaces, base classes, shared utilities
- **Critical paths**: Authentication, data flow, state management
- **Gotchas**: Non-obvious behaviors, edge cases, pitfalls to avoid
- **Dependencies**: Important libraries and their usage patterns
- **Test strategies**: How to test different parts of the system

### What NOT to Include
- Implementation details that are clear from code
- Temporary TODOs (use code comments instead)
- Change logs (use git history)
- API documentation (use code docs/comments)
- General programming knowledge
- **Test counts or execution times** (these change frequently and provide no useful context)
- **Build commands and scripts** - These live in package.json. Only document non-obvious usage patterns.
- **Metadata footers** - No "Last Updated" dates (use git), version numbers (use package.json), or feature summaries (redundant with content)

### Update Format
Keep updates concise and scannable. Use clear section headers. Focus on context that helps make better decisions faster.

**Balance conciseness with clarity**:
- Prefer bullet points over paragraphs
- Remove obvious information, but keep context that explains "why"
- Show code examples when they clarify non-obvious patterns
- Aim for information density, but prioritize understandability over brevity
- **Keep file/test organization trees** - they help navigate the codebase
- **Keep method signatures and parameters** - they document the API surface
- **Allow some duplication** when it helps understanding (e.g., listing capabilities in overview + detailed sections)

### Git Commit Rules
**NEVER use co-authoring in git commits.** Always commit as the sole author. Do not add "Co-authored-by" trailers to commit messages under any circumstances.

**NEVER add "Generated by Claude Code" or similar attribution** to commit messages. Commit messages should describe the change only, without mentioning AI assistance.

### Code Documentation Rules
**Do not over-document.** Only add comments for:
- Non-obvious business logic or algorithms
- Complex edge cases or gotchas
- Why decisions were made (not what the code does)

Avoid documenting:
- Obvious functionality that's clear from well-named functions/variables
- Redundant type information already in signatures
- What standard library functions do
- Implementation details that are self-explanatory

Good code with clear naming is better than heavily commented code.

**Do not create separate documentation files for features.** Keep documentation minimal and centralized:
- Feature descriptions belong in README.md, kept concise
- Do NOT create individual .md files for each feature or module
- Code should be self-documenting through clear naming and structure
- Only create additional docs if absolutely necessary for complex systems

Avoid documentation sprawl. Less is more.

### Testing and Token Optimization
**IMPORTANT - Token Efficiency**: When running full test suite to verify no breakage, ALWAYS filter output to show only summary:
NEVER run full test output without filtering - console logs consume thousands of tokens unnecessarily.

---

## Project Overview

JellyNext is a Jellyfin plugin that integrates Trakt-powered discovery directly into Jellyfin. It creates per-user virtual libraries for personalized recommendations and new season notifications, with one-click download triggers to Radarr/Sonarr.

**Core capabilities:**
- Per-user Trakt account linking (each Jellyfin user links their own Trakt)
- Virtual libraries: Recommendations and New Seasons (personalized per user)
- One-click downloads via Radarr/Sonarr integration
- Smart Play/Download button switching (shows Play if media exists, Download if not)
- Metadata enrichment via TMDB

## Tech Stack

- **Platform**: C# / .NET 8.0
- **Framework**: Jellyfin Plugin SDK 10.9+
- **External APIs**:
  - Trakt API (OAuth2 for per-user auth)
  - TMDB API (metadata & images)
  - Radarr/Sonarr APIs (download triggers)
- **Code Quality**: StyleCop.Analyzers + jellyfin.ruleset

## Architecture

### Project Structure
```
Jellyfin.Plugin.JellyNext/
├── Configuration/
│   ├── PluginConfiguration.cs   # Global plugin settings
│   └── configPage.html           # Admin web UI (OAuth + config)
├── Api/
│   ├── TraktController.cs        # OAuth endpoints
│   ├── RadarrController.cs       # Radarr test connection endpoint
│   ├── SonarrController.cs       # Sonarr test connection endpoint
│   └── JellyNextLibraryController.cs # REST API for virtual library content
├── Services/
│   ├── TraktApi.cs               # Trakt API integration
│   ├── RadarrService.cs          # Radarr API integration (test, add movies)
│   ├── SonarrService.cs          # Sonarr API integration (test connection)
│   ├── TmdbService.cs            # TMDB API key management (custom or Jellyfin's)
│   ├── ContentCacheService.cs    # In-memory cache for synced content
│   ├── ContentSyncService.cs     # Orchestrates syncing across providers
│   ├── PlaybackInterceptor.cs    # IHostedService for playback event monitoring
│   └── StartupSyncService.cs     # IHostedService for triggering sync at startup
├── Providers/
│   ├── IContentProvider.cs       # Interface for content providers
│   └── RecommendationsProvider.cs # Trakt recommendations implementation
├── Resolvers/
│   └── JellyNextResolver.cs      # IItemResolver for .strm stub files
├── VirtualLibrary/
│   ├── VirtualLibraryManager.cs  # Creates/manages per-user .strm stub files
│   ├── VirtualLibraryCreator.cs  # Initializes virtual library on startup
│   └── VirtualLibraryContentType.cs # Content type enum and helpers
├── ScheduledTasks/
│   └── ContentSyncScheduledTask.cs # Jellyfin scheduled task for syncing
├── Models/
│   ├── TraktUser.cs              # Per-user OAuth storage
│   ├── TraktDeviceCode.cs        # OAuth device flow
│   ├── TraktUserAccessToken.cs   # OAuth tokens
│   ├── TraktUserRefreshTokenRequest.cs
│   ├── TraktMovie.cs             # Trakt movie response
│   ├── TraktShow.cs              # Trakt show response
│   ├── TraktIds.cs               # External IDs (TMDB, IMDB, TVDB, etc)
│   ├── RadarrMovie.cs            # Radarr movie (add/retrieve)
│   ├── RadarrQualityProfile.cs   # Radarr quality profile
│   ├── RadarrRootFolder.cs       # Radarr root folder
│   ├── RadarrSystemStatus.cs     # Radarr system status
│   ├── RadarrTestConnectionResponse.cs # Radarr test result
│   ├── SonarrQualityProfile.cs   # Sonarr quality profile
│   ├── SonarrRootFolder.cs       # Sonarr root folder
│   ├── SonarrSystemStatus.cs     # Sonarr system status
│   ├── SonarrTestConnectionResponse.cs # Sonarr test result
│   ├── SonarrSeries.cs           # Sonarr series (add/retrieve)
│   ├── SonarrSeason.cs           # Sonarr season with monitoring
│   ├── SonarrAddOptions.cs       # Sonarr add options
│   ├── ContentItem.cs            # Unified content representation
│   └── ContentType.cs            # Movie/Show enum
├── Helpers/
│   └── UserHelper.cs             # TraktUser lookup utility
├── Plugin.cs                     # Entry point + IServerApplicationHost
└── PluginServiceRegistrator.cs  # DI service registration
```

### Key Plugin Components
- **Plugin.cs**: Main entry point, inherits `BasePlugin<PluginConfiguration>`, tracks OAuth polling tasks, exposes `IServerApplicationHost`
- **PluginConfiguration**: Stores global settings (Radarr/Sonarr URLs/keys/profiles/folders, optional TMDB key, cache expiration, ignore filters, per-user TraktUser array)
- **PluginServiceRegistrator**: Registers all services and content providers in DI container
- **TraktController**: REST endpoints for OAuth (authorize, deauthorize, status check)
- **RadarrController**: REST endpoint for testing Radarr connection
- **SonarrController**: REST endpoint for testing Sonarr connection
- **JellyNextLibraryController**: REST API for accessing virtual library content (recommendations queries)
- **TraktApi**: Handles OAuth device flow, token refresh, authenticated API calls, recommendations fetching
- **RadarrService**: Handles Radarr API interactions (test connection, retrieve profiles/folders, add movies)
- **SonarrService**: Handles Sonarr API interactions (test connection, retrieve profiles/folders, add series with season-specific monitoring, anime support)
- **PlaybackInterceptor**: IHostedService that subscribes to session playback events, detects virtual item playback, triggers downloads for movies (Radarr) and TV shows (Sonarr)
- **StartupSyncService**: IHostedService that triggers content sync at plugin startup (waits 5 seconds for initialization)
- **TmdbService**: Manages TMDB API key (uses custom if provided, falls back to Jellyfin's via reflection)
- **ContentCacheService**: In-memory per-user, per-provider cache with automatic expiration
- **ContentSyncService**: Orchestrates syncing across all registered `IContentProvider` implementations
- **IContentProvider**: Modular interface for content sources (recommendations, watchlist, trending, etc.)
- **ContentSyncScheduledTask**: Jellyfin scheduled task (configurable in Dashboard), triggers virtual library refresh
- **JellyNextResolver**: IItemResolver that intercepts .strm stub files and converts them to Movie objects with metadata
- **VirtualLibraryManager**: Creates and manages .strm stub files for recommendations in plugin data directory
- **VirtualLibraryCreator**: Initializes virtual library directory on plugin startup

## Key Conventions

### Jellyfin Plugin Standards
- Follow `jellyfin.ruleset` for code analysis (enforced via StyleCop.Analyzers)
- Use XML documentation for public APIs (GenerateDocumentationFile enabled)
- Enable nullable reference types
- Embed web resources (HTML/JS) into assembly

### HTTP Client Usage
- **ALWAYS use `NamedClient.Default`** when creating HTTP clients: `_httpClientFactory.CreateClient(NamedClient.Default)`
- This uses Jellyfin's preconfigured "happy eyeballs" HTTP client
- Required for Trakt API to work (avoids Cloudflare blocks)
- `NamedClient` from `MediaBrowser.Common.Net` namespace

### Trakt API Headers
- **Only two headers required**: `trakt-api-version: 2` and `trakt-api-key: {client_id}`
- Do NOT add User-Agent or Accept headers (causes issues)
- Base URL: `https://api.trakt.tv`
- Endpoints: `/oauth/device/code`, `/oauth/device/token`, `/oauth/token`

### Dependency Injection
- Register services in `PluginServiceRegistrator.cs` implementing `IPluginServiceRegistrator`
- Must register `AddHttpClient()` before services that use `IHttpClientFactory`
- Services auto-discovered by Jellyfin on plugin load
- Content providers registered as `IContentProvider` interface - automatically discovered by `ContentSyncService`

### Per-User Architecture Pattern
- Virtual libraries must be **filtered by current Jellyfin user**
- Each user has their own Trakt OAuth token (stored per-user, not global)
- Item resolution checks user context to return personalized content
- Download triggers use global Radarr/Sonarr credentials but are initiated per-user

### Smart Play/Download Switching
- Before returning virtual item: check if media exists in Jellyfin by TMDB/TVDB ID
- If exists: return real Jellyfin item ID → shows native Play button
- If not exists: return virtual item with `plugin://jellynext/download/{id}` → triggers download on Play
- Works cross-client (Web, iOS, Android, TV, Kodi) via playback interception

## Important Constraints

### Jellyfin Plugin Limitations
- No native "Download" button in clients → use playback interception workaround
- Virtual items must implement proper metadata interfaces to appear correctly
- Embedded resources (HTML/JS) require specific .csproj configuration
- Plugin GUID must be unique and stable: `a4df60c5-6ab4-412a-8f79-2cab93fb2bc5`

### API Rate Limits
- Trakt: respect rate limits (implement caching + scheduled sync)
- TMDB: cache metadata aggressively
- Radarr/Sonarr: minimal calls (only on user-triggered downloads)

### Cross-Client Compatibility
- Must work on all official Jellyfin clients (Web, iOS, Android, TV, Kodi)
- Cannot rely on Web UI-only features for core functionality
- Optional: Web UI JavaScript injection for enhanced UX

### Modular Content Provider System
- **IContentProvider interface**: Extensible contract for content sources
  - `ProviderName`: Unique identifier (e.g., "recommendations", "watchlist")
  - `LibraryName`: Display name for virtual library
  - `FetchContentAsync(userId)`: Fetches content for specific user
  - `IsEnabledForUser(userId)`: Checks if provider enabled for user
- **Easy to add new providers**: Create class implementing `IContentProvider`, register in DI → automatic sync/caching
- **ContentItem model**: Unified representation (movies + shows, all external IDs)
- **ContentSyncService**: Orchestrates syncing across all providers with error isolation
- **ContentCacheService**: Per-user, per-provider in-memory cache with configurable expiration

### TMDB API Key Management
- **Optional configuration**: Users can provide custom TMDB API key (free at themoviedb.org)
- **Automatic fallback**: If no key provided, uses Jellyfin's built-in TMDB key via reflection
- **Benefits of custom key**: Dedicated rate limits, avoids high-traffic metadata issues
- **TmdbService.GetTmdbApiKey()**: Handles custom key priority + reflection fallback with caching

## Implemented Features

### ✅ Per-User Trakt OAuth (Device Flow)
**Architecture:**
- Trakt Client ID/Secret embedded in `TraktApi.cs` (not in config)
- Per-user OAuth tokens stored in `PluginConfiguration.TraktUsers[]` array
- Each `TraktUser` has: `AccessToken`, `RefreshToken`, `LinkedMbUserId`, `AccessTokenExpiration`

**OAuth Device Flow:**
1. Admin selects Jellyfin user in plugin config page
2. Click "Link Trakt Account" → `POST /JellyNext/Trakt/Users/{userGuid}/Authorize`
3. Backend requests device code from Trakt API
4. Frontend displays user code + trakt.tv/activate link
5. Background polling task checks authorization every 3 seconds
6. On success: stores access/refresh tokens in `TraktUser`, saves config
7. Frontend auto-detects completion and shows success

**Automatic Token Refresh:**
- Tokens expire with 75% safety buffer (`ExpirationWithBuffer`)
- `EnsureValidAccessToken()` checks expiration before every API call
- `RefreshUserAccessToken()` exchanges refresh token for new access token
- Trakt rotates refresh tokens on each refresh (new tokens saved automatically)

**Key Methods:**
- `TraktApi.AuthorizeDevice(traktUser)` - Initiates device flow
- `TraktApi.PollForAccessToken(deviceCode, traktUser)` - Background polling
- `TraktApi.RefreshUserAccessToken(traktUser)` - Token refresh
- `TraktApi.CreateTraktClient(traktUser)` - Creates authenticated HTTP client with auto-refresh
- `UserHelper.GetTraktUser(userGuid)` - Lookup TraktUser by Jellyfin user ID

**API Endpoints:**
- `POST /JellyNext/Trakt/Users/{userGuid}/Authorize` - Start OAuth
- `GET /JellyNext/Trakt/Users/{userGuid}/AuthorizationStatus` - Check status
- `POST /JellyNext/Trakt/Users/{userGuid}/Deauthorize` - Revoke access

### ✅ Trakt Recommendations API
**Endpoints:**
- `TraktApi.GetMovieRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized movie recommendations
- `TraktApi.GetShowRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized show recommendations

**Configuration:**
- `IgnoreCollected` (default: true) - Filter out items in user's Trakt collection
- `IgnoreWatchlisted` (default: false) - Filter out items in user's watchlist
- Both configurable via plugin settings page

**Implementation:**
- Returns `TraktMovie[]` and `TraktShow[]` with IDs (Trakt, TMDB, IMDB, TVDB)
- Automatic token refresh before API calls
- Error handling with empty array fallback

### ✅ Modular Content Sync System
**Architecture:**
- `ContentSyncScheduledTask` - Jellyfin scheduled task (appears in Dashboard → Scheduled Tasks)
- Default triggers: at startup + every 6 hours (user-configurable in Dashboard)
- `ContentSyncService.SyncAllAsync()` - Syncs all users across all registered providers
- Per-provider error isolation - one failure doesn't break entire sync
- Automatic library scan after sync - triggers Jellyfin scan for all virtual libraries to update UI

**Caching:**
- `ContentCacheService` - In-memory cache per user per provider
- `CacheExpirationHours` config (default: 6 hours) - Controls data freshness
- Cache serves instant results for virtual library browsing
- Protects against Trakt API rate limits

**Sync Workflow:**
1. Fetch content from all providers for all users (e.g., Trakt recommendations)
2. Update in-memory cache with fresh data
3. Refresh .strm stub files in all user directories
4. Trigger Jellyfin library scan to detect new/removed items
5. Virtual libraries update in UI automatically

**Current Providers:**
- `RecommendationsProvider` - Fetches movie + show recommendations (up to 50 each)

### ✅ Per-User Native Virtual Libraries
**Architecture:**
- Creates Jellyfin-native virtual libraries that work in all clients without custom UI
- **Per-user isolation**: Each user has their own directory with personalized recommendations
- Uses .strm stub files as a bridge between cached recommendations and Jellyfin's item system
- Full metadata resolution via TMDB provider IDs (posters, descriptions, cast)

**Directory Structure:**
- **Base**: `<plugin-data>/jellynext-virtual/`
- **Per-user format**: `jellynext-virtual/[userId]/[content-type]/`
- **Example**: `jellynext-virtual/12345678-1234-1234-1234-123456789012/movies_recommendations/`
- **Content types**: `movies_recommendations`, `shows_recommendations`, `watchlist_movies`, `watchlist_shows`
- **Scalable**: Easy to add new content types (trending, calendar, etc.)

**Content Type System:**
- `VirtualLibraryContentType` enum defines available content types
- `VirtualLibraryContentTypeHelper` provides standardized naming/mapping:
  - `GetDirectoryName()`: "movies_recommendations"
  - `GetProviderName()`: "recommendations"
  - `GetDisplayName()`: "Movie Recommendations"
  - `GetMediaType()`: "Movies" or "Shows"
  - `TryParseDirectoryName()`: Parse directory name back to enum

**Stub File System:**
- **Format**: `Title (Year) [tmdbid-ID].strm` (e.g., `Thor (2011) [tmdbid-10195].strm`)
- **Content**: Points to dummy.mp4 path for FFprobe compatibility
- **Why .strm**: Jellyfin recognizes .strm as streaming content and skips FFprobe (prevents errors)
- **Isolation**: Each user's files in separate directory, no cross-user data leakage
- **Empty directory handling**: `.keep` placeholder file maintained in all directories to prevent Jellyfin from ignoring empty recommendation folders

**Resolver Integration:**
- `JellyNextResolver` implements `IItemResolver` with `ResolverPriority.Plugin`
- Intercepts .strm files in `jellynext-virtual` folder during library scans
- Extracts **userId** and **content type** from path using regex: `@"jellynext-virtual[/\\]([a-f0-9-]+)[/\\]([^/\\]+)[/\\]"`
- Extracts TMDB ID from filename using regex: `\[tmdbid-(\d+)\]$`
- Looks up movie details in ContentCacheService **for specific user**
- Creates Movie object with proper metadata and provider IDs
- Sets TMDB/IMDB ProviderIds for metadata lookup by Jellyfin's metadata providers

**Automatic Sync:**
- `VirtualLibraryManager.RefreshStubFiles()` syncs **all users** (not just admin)
- `VirtualLibraryManager.RefreshStubFilesForUser(userId, contentType)` syncs specific user/type
- Creates new .strm files for new recommendations
- Removes old .strm files for removed recommendations
- File naming includes title/year for human readability and proper Jellyfin parsing
- Per-user directories created automatically on first sync

**Migration from Single-User:**
- `MigrateOldStructure()` detects old .strm files in root directory
- Automatically deletes old files on first run after upgrade
- Logs migration progress
- New per-user structure created cleanly

**Library Organization:**
- **One library per content type per user** (not one library per user!)
- Example for one user:
  - Library 1: "admin's Movies Recommendations" → `jellynext-virtual/[userId]/movies_recommendations/`
  - Library 2: "admin's Shows Recommendations" → `jellynext-virtual/[userId]/shows_recommendations/`
  - Library 3: "admin's Movie Watchlist" → `jellynext-virtual/[userId]/watchlist_movies/`
- This allows granular control and better organization in Jellyfin UI
- Each library can have different visibility/permissions

**Setup Process:**
1. Plugin creates `jellynext-virtual` base directory on startup
2. Logs per-user, per-content-type setup instructions with exact paths
3. Sync task populates per-user, per-content-type directories with .strm stub files
4. Admin creates SEPARATE library for EACH content type:
   - Add "admin's Movies Recommendations" → Movies library → `jellynext-virtual/[userId]/movies_recommendations/`
   - Add "admin's Shows Recommendations" → Shows library → `jellynext-virtual/[userId]/shows_recommendations/`
   - (Repeat for each user and content type)
5. Jellyfin scans each library independently
6. Resolver converts stubs to Movie/Show objects with user context
7. Metadata providers fetch posters/info using TMDB IDs
8. Content appears in respective libraries with full metadata

**Current Implementation:**
- ✅ Full per-user isolation
- ✅ Movies recommendations support
- ✅ Shows recommendations support
- ⏳ Watchlist support (future: new content provider)

### ✅ Radarr Configuration with Test Connection
**Architecture:**
- Admin-configured Radarr settings stored in `PluginConfiguration`
- Interactive test connection validates credentials and retrieves available options
- `RadarrService` handles all Radarr API interactions
- `RadarrController` exposes REST endpoint for frontend

**Configuration Properties:**
- `RadarrUrl` - Base URL (e.g., `http://radarr:7878`)
- `RadarrApiKey` - API key from Radarr settings
- `RadarrQualityProfileId` - Selected quality profile ID
- `RadarrRootFolderPath` - Selected root folder path

**Models:**
- `RadarrQualityProfile` - Profile info (id, name)
- `RadarrRootFolder` - Folder info (id, path, freeSpace)
- `RadarrSystemStatus` - System info (version)
- `RadarrTestConnectionResponse` - Test result with profiles and folders

**Service Methods:**
- `RadarrService.TestConnectionAsync(url, apiKey)` - Validates connection and retrieves options
  - Calls `/api/v3/system/status` - Verifies connection
  - Calls `/api/v3/qualityprofile` - Gets available profiles
  - Calls `/api/v3/rootfolder` - Gets available folders
  - Returns `RadarrTestConnectionResponse` with all data

**API Endpoint:**
- `GET /JellyNext/Radarr/TestConnection?radarrUrl={url}&apiKey={key}` - Test connection

**Configuration UI Flow:**
1. Admin enters Radarr URL and API key
2. Clicks "Test Connection" button
3. Frontend calls test endpoint with credentials
4. Backend validates and retrieves profiles/folders
5. Success: Shows version + populates quality profile and root folder dropdowns
6. Failure: Shows error message
7. Admin selects preferred profile and folder
8. Clicks "Save Configuration" to persist settings
9. UI pre-selects saved values when testing connection again

**Important Notes:**
- Uses `NamedClient.Default` HTTP client (same as TraktApi)
- API returns PascalCase JSON (C# default serialization)
- JavaScript must use `result.Success`, `result.QualityProfiles`, etc. (not camelCase)
- Root folder dropdown shows available space formatted as human-readable size
- Connection can be re-tested to change profile/folder without re-entering credentials

### ✅ Sonarr Configuration with Test Connection
**Architecture:**
- Admin-configured Sonarr settings stored in `PluginConfiguration`
- Interactive test connection validates credentials and retrieves available options
- `SonarrService` handles all Sonarr API interactions
- `SonarrController` exposes REST endpoint for frontend

**Configuration Properties:**
- `SonarrUrl` - Base URL (e.g., `http://sonarr:8989`)
- `SonarrApiKey` - API key from Sonarr settings
- `SonarrQualityProfileId` - Selected quality profile ID
- `SonarrRootFolderPath` - Root folder for regular TV shows
- `SonarrAnimeRootFolderPath` - Optional separate root folder for anime (key difference from Radarr)

**Models:**
- `SonarrQualityProfile` - Profile info (id, name)
- `SonarrRootFolder` - Folder info (id, path, freeSpace)
- `SonarrSystemStatus` - System info (version)
- `SonarrTestConnectionResponse` - Test result with profiles and folders

**Service Methods:**
- `SonarrService.TestConnectionAsync(url, apiKey)` - Validates connection and retrieves options
  - Calls `/api/v3/system/status` - Verifies connection
  - Calls `/api/v3/qualityprofile` - Gets available profiles
  - Calls `/api/v3/rootfolder` - Gets available folders
  - Returns `SonarrTestConnectionResponse` with all data

**API Endpoint:**
- `GET /JellyNext/Sonarr/TestConnection?sonarrUrl={url}&apiKey={key}` - Test connection

**Configuration UI Flow:**
1. Admin enters Sonarr URL and API key
2. Clicks "Test Connection" button
3. Frontend calls test endpoint with credentials
4. Backend validates and retrieves profiles/folders
5. Success: Shows version + populates quality profile, root folder, and anime root folder dropdowns
6. Failure: Shows error message
7. Admin selects preferred profile and folders (anime folder optional)
8. Clicks "Save Configuration" to persist settings
9. UI pre-selects saved values when testing connection again

**Important Notes:**
- Uses `NamedClient.Default` HTTP client (same as TraktApi and RadarrService)
- API returns PascalCase JSON (C# default serialization)
- JavaScript must use `result.Success`, `result.QualityProfiles`, etc. (not camelCase)
- Anime root folder is optional - defaults to "Same as regular shows..." if not specified
- Root folder dropdowns show available space formatted as human-readable size
- Connection can be re-tested to change profile/folders without re-entering credentials

### ✅ Playback Interception for Movie Downloads
**Architecture:**
- `PlaybackInterceptor` - Hosted service that monitors playback events
- Implements `IHostedService` for automatic startup with plugin
- Registered in `PluginServiceRegistrator` as hosted service

**How It Works:**
1. Service subscribes to `ISessionManager.PlaybackStart` event on startup
2. When user attempts to play any media, event handler checks if path contains "jellynext-virtual"
3. If virtual item detected:
   - Extracts TMDB ID from filename using regex: `\[tmdbid-(\d+)\]$`
   - Extracts user ID from path using regex: `jellynext-virtual[/\\]([a-f0-9-]+)[/\\]`
   - Looks up movie details from `ContentCacheService`
   - Calls `RadarrService.AddMovieAsync()` to add movie to Radarr
   - Stops playback immediately using `SendPlaystateCommand(Stop)`
   - Sends user notification via `SendMessageCommand()` with success/failure message
   - Message displays for 5 seconds with title "JellyNext Download"

**Service Components:**
- `PlaybackInterceptor(ISessionManager, RadarrService, ContentCacheService)` - Constructor with DI
- `StartAsync()` - Subscribes to PlaybackStart event
- `StopAsync()` - Unsubscribes from event
- `OnPlaybackStart(object, PlaybackProgressEventArgs)` - Event handler for playback detection

**Radarr Integration:**
- `RadarrService.AddMovieAsync(tmdbId, title, year)` - Adds movie to Radarr
  - Uses configured `RadarrUrl`, `RadarrApiKey`, `RadarrQualityProfileId`, `RadarrRootFolderPath`
  - Checks if movie already exists in Radarr (avoids duplicates)
  - Sets `Monitored = true` and `SearchForMovie = true` (triggers immediate search)
  - Returns `RadarrMovie` on success, `null` on failure

**Models:**
- `RadarrMovie` - Represents movie in Radarr (id, title, tmdbId, qualityProfileId, rootFolderPath, monitored, addOptions)
- `RadarrAddOptions` - Add options (searchForMovie)

**Cross-Client Support:**
- Works on all Jellyfin clients (Web, Android, iOS, TV, Kodi)
- No client modifications required
- Operates at server API level via session manager events
- User experience: Click Play → Playback stops immediately → Notification appears → Movie downloading in background

**User Notifications:**
- Success message: "{Title} ({Year}) has been added to your download queue and will appear in your library shortly."
- Failure message: "Failed to add {Title} ({Year}) to download queue. Please check your Radarr configuration."
- Notification displayed via `ISessionManager.SendMessageCommand()`
- Shows for 5 seconds with header "JellyNext Download"
- Works across all Jellyfin clients (Web, mobile, TV apps)

**Error Handling:**
- Validates TMDB ID extraction from filename
- Validates user ID extraction from path
- Checks if movie exists in cache before triggering download
- Gracefully handles message/playback stop failures (logs warnings, doesn't block download)
- Logs all errors (invalid path format, missing cache entry, Radarr API failures)
- Invalid requests logged but don't crash plugin

**Important Notes:**
- Playback stops immediately when virtual item detected (no buffering or error screens)
- User receives immediate feedback via on-screen notification
- Download happens in background - also visible in Radarr activity

### ✅ Playback Interception for TV Show Downloads
**Architecture:**
- `PlaybackInterceptor` now handles both movies and TV shows
- Detects content type by path pattern (`movies_` vs `shows_`)
- `SonarrService` injected alongside `RadarrService`

**Per-Season Download Strategy:**
- Virtual library creates fake episodes for seasons 1-10 in each show folder
- Format: `S##E01 - Download Season #.strm` (e.g., `S01E01 - Download Season 1.strm`)
- Jellyfin treats these as episodes, displays them in season view
- User clicks specific season episode to download that season only

**How It Works:**
1. Service detects playback attempt on show episode in virtual library
2. Extracts season number from filename using regex: `S(\d+)E\d+`
3. Extracts TVDB ID from parent folder name: `\[tvdbid-(\d+)\]$`
4. Looks up show details from `ContentCacheService`
5. Detects if anime using title heuristics
6. Calls `SonarrService.AddSeriesAsync(tvdbId, title, year, seasonNumber, isAnime)`
7. Stops playback immediately and sends notification

**Sonarr Integration:**
- `SonarrService.AddSeriesAsync(tvdbId, title, year, seasonNumber, isAnime)` - Adds series with season monitoring
  - Uses configured `SonarrUrl`, `SonarrApiKey`, `SonarrQualityProfileId`
  - **Root folder selection**: Uses `SonarrAnimeRootFolderPath` if `isAnime=true`, else `SonarrRootFolderPath`
  - **Series monitored**: `Monitored = true` (required for Sonarr to function)
  - **Season-specific monitoring**: Only requested season has `Monitored = true` in seasons array
  - **Prevents mass downloads**: Other seasons remain unmonitored
  - **Smart updates**: If series exists, monitors new season and triggers search
  - **Immediate search**: `SearchForMissingEpisodes = true` triggers download
  - Returns `SonarrSeries` on success, `null` on failure

**Models:**
- `SonarrSeries` - Represents series in Sonarr (id, title, tvdbId, qualityProfileId, rootFolderPath, monitored, seasons, seriesType)
- `SonarrSeason` - Season info (seasonNumber, monitored)
- `SonarrAddOptions` - Add options (searchForMissingEpisodes)

**Anime Detection:**
- Simple heuristic checks title for keywords: anime, shippuden, my hero academia, attack on titan, dragon ball, one piece, naruto, bleach, demon slayer, death note
- Can be enhanced later with Trakt genres, TVDB tags, or user configuration
- Determines which root folder to use (anime vs regular)

**User Notifications:**
- Success: "{Title} ({Year}) - Season {Season} has been added to your download queue and will appear in your library shortly."
- Failure: "Failed to add {Title} ({Year}) - Season {Season} to download queue. Please check your Sonarr configuration."
- 5-second timeout notification

**Cross-Client Support:**
- Works on all Jellyfin clients (Web, Android, iOS, TV, Kodi)
- No client modifications required
- User experience: Click Play on season episode → Playback stops → Notification → Season downloading

**Important Notes:**
- Series is monitored but only specific seasons are monitored at season level
- Prevents automatic downloads of unwanted seasons
- User can download multiple seasons by clicking respective fake episodes
- Future episodes of monitored season will auto-download if aired

## Core Workflows

### Initial Setup (Admin)
1. Admin configures plugin via Jellyfin Dashboard
2. (Optional) Enter custom TMDB API key (uses Jellyfin's key if not provided)
3. Enter Radarr/Sonarr URLs + API keys
4. Configure recommendation filters (ignore collected/watchlisted)
5. Set cache expiration (default: 6 hours)
6. Configure sync schedule in Dashboard → Scheduled Tasks → "Sync Trakt Content"

### User Trakt Linking (Per-User)
1. Admin opens plugin config → selects Jellyfin user from dropdown
2. Clicks "Link Trakt Account" → receives user code
3. User visits trakt.tv/activate and enters code
4. Plugin auto-detects authorization completion
5. Tokens stored in `PluginConfiguration.TraktUsers[]` for that user

### Virtual Library Display
1. User opens specific library (e.g., "admin's Movies Recommendations")
2. Plugin resolves .strm files, extracting userId and content type from path
3. Fetches that user's cached content for that specific content type
4. For each item: check if exists in Jellyfin by TMDB ID
5. Return existing item ID (Play) or virtual item (Download)
6. Enrich with TMDB metadata (poster, description)

### Download Trigger (Movies)
1. User clicks Play on virtual movie (recommendation not yet in library)
2. PlaybackInterceptor detects virtual item path during PlaybackStart event
3. Extracts TMDB ID from .strm filename and user ID from path
4. Looks up movie details in ContentCacheService
5. Calls Radarr API to add movie (with monitoring + search enabled)
6. Stops playback immediately via SendPlaystateCommand(Stop)
7. Displays on-screen notification to user (5 second timeout)
8. Download proceeds in background, visible in Radarr activity

### Download Trigger (TV Shows)
1. User clicks Play on virtual show episode (e.g., "S01E01 - Download Season 1")
2. PlaybackInterceptor detects virtual item path during PlaybackStart event
3. Extracts season number from filename (S##E## pattern) and user ID from path
4. Extracts TVDB ID from parent folder name
5. Looks up show details in ContentCacheService
6. Detects if anime using title heuristics
7. Calls Sonarr API to add series with specific season monitored
8. Stops playback immediately via SendPlaystateCommand(Stop)
9. Displays on-screen notification to user (5 second timeout)
10. Download proceeds in background, visible in Sonarr activity

## Important Gotchas

### Trakt API OAuth
- **Cloudflare Protection**: Trakt API is behind Cloudflare - must use `NamedClient.Default` HTTP client
- **No Custom Headers**: Only use `trakt-api-version` and `trakt-api-key` headers (User-Agent/Accept cause blocks)
- **Token Safety Buffer**: Use 75% of token lifetime before refresh to prevent race conditions
- **Refresh Token Rotation**: Trakt rotates refresh tokens on each refresh - always save new tokens
- **Background Polling**: OAuth device flow polls in background - track with `Plugin.Instance.PollingTasks` dictionary

### Configuration Access
- Use `Plugin.Instance?.Configuration` not `Plugin.Instance?.PluginConfiguration`
- `BasePlugin<T>` exposes config as `Configuration` property
- `UserHelper.GetTraktUser(userGuid)` is the standard way to lookup per-user tokens

### TMDB API Key Access
- **TmdbService** handles TMDB API key with intelligent fallback
- Custom key from config is prioritized
- Fallback uses reflection to access Jellyfin's TMDB plugin configuration
- Reflection path: `IServerApplicationHost` → `PluginManager` → `TmdbPlugin` → `Configuration.TmdbApiKey`
- Cached after first reflection lookup for performance

### Content Sync Architecture
- **Scheduled task** (`ContentSyncScheduledTask`) registered with Jellyfin's task manager
- **Startup sync** via `StartupSyncService` (IHostedService):
  - Runs automatically on plugin startup (waits 5 seconds for Jellyfin initialization)
  - Finds and executes ContentSyncScheduledTask programmatically via `ITaskManager`
  - More reliable than `TriggerStartup` (which only works on first task registration)
  - Runs in background, doesn't block server startup
- **Interval trigger**: Default 6 hours (user can change in Dashboard)
- `GetDefaultTriggers()` returns only interval trigger (startup handled by hosted service)
- **Cache expiration** is separate from sync schedule (prevents indefinitely stale data)
- Cache serves instant responses when browsing virtual libraries
- Sync refreshes cache on schedule or manual trigger
- **Automatic library scan**: After sync completes, scans only virtual libraries (not all libraries!)
  - Identifies virtual libraries by checking if path contains "jellynext-virtual"
  - For each virtual library: `FindByPath()` → `Folder.ValidateChildren()` for that specific library
  - Uses `MetadataRefreshOptions` with `ReplaceAllMetadata = false` (only scans for new/removed items)
  - Scan is best-effort - errors logged as warnings, don't block sync
  - Ensures new/removed recommendations appear in UI without manual scan
  - Much more efficient than scanning all libraries

### Virtual Library Stub Files (Per-User Architecture)
- **Must use .strm extension**: Jellyfin recognizes .strm as streaming content and skips FFprobe
- **Empty directory handling**: Always maintain a `.keep` file in each content directory - Jellyfin refuses to scan empty directories and will remove libraries pointing to empty folders
- **Different structures for movies vs shows**:
  - **Movies**: Flat .strm files in root directory
    - Format: `Title (Year) [tmdbid-ID].strm`
    - Example: `Thor (2011) [tmdbid-10195].strm`
    - Resolved by: `ResolveStubFile()` method
  - **Shows**: Folder structure with per-season fake episodes
    - Format: `Title (Year) [tvdbid-ID]/S##E01 - Download Season #.strm`
    - Example: `Black Mirror (2011) [tvdbid-253463]/S01E01 - Download Season 1.strm`
    - Creates seasons 1-10 by default (users can trigger higher seasons manually)
    - Jellyfin treats these as episodes, displays in season view
    - Resolved by: `ResolveShowFolder()` method - detects directories with `[tvdbid-XXX]` pattern
    - PlaybackInterceptor extracts season from `S##E##` pattern in filename
- **Title/Year parsing**: Jellyfin's metadata providers parse title and year from filename/folder name before using provider IDs
- **Path structure**: `jellynext-virtual/[userId]/[content-type]/` for per-user isolation
- **Regex extraction**: Resolver uses patterns:
  - Path: `@"jellynext-virtual[/\\]([a-f0-9-]+)[/\\]([^/\\]+)[/\\]"` to extract userId and content type
  - Movie filename: `\[tmdbid-(\d+)\]$` to extract TMDB ID
  - Show folder name: `\[tvdbid-(\d+)\]$` to extract TVDB ID
- **Sanitize filenames**: Remove invalid characters from titles (replace with underscore)
- **Per-user library setup**: Each user needs separate library pointing to their directory (e.g., `jellynext-virtual/[userId]/movies_recommendations` or `jellynext-virtual/[userId]/shows_recommendations`)
- **Resolver specificity**: Only intercepts paths containing `jellynext-virtual` (avoids interfering with other content)
- **Provider IDs essential**:
  - Movies: Must set TMDB and IMDB ProviderIds on Movie object for metadata to resolve
  - Shows: Must set TVDB (primary), TMDB, and IMDB ProviderIds on Series object for metadata to resolve
- **User context**: Resolver looks up content in cache using extracted userId - ensures each user sees only their recommendations
- **Content type mapping**: Directory name (e.g., `movies_recommendations` or `shows_recommendations`) maps to provider name (e.g., `recommendations`) via `VirtualLibraryContentTypeHelper`

### FFprobe Compatibility for Cross-Client Support
**Problem**: Some Jellyfin clients (especially iOS/tvOS) probe .strm files with FFprobe when opening item details, causing crashes if:
- File contains invalid protocols like `plugin://` → "Protocol not found" error
- File contains unreachable HTTP URLs → "Input/output error"
- File is empty → FFprobe fails with null streams/format

**Solution - Embedded Dummy Video File**:
- **Embed minimal valid video** - Plugin includes pre-generated `dummy.mp4` (~2MB, 1-hour black video, 2x2 pixels) as embedded resource
- **Extract on initialization** - Copies embedded video from assembly to plugin data directory once
- **Point .strm files to dummy** - All .strm files contain absolute path to dummy video: `/path/to/jellynext-virtual/dummy.mp4`
- **FFprobe succeeds** - FFprobe can read the dummy video and extract valid stream info (h264 video, no audio)
- **Playback still intercepted** - PlaybackInterceptor detects by path pattern `jellynext-virtual`, not file content
- **Fallback to HTTP** - If extraction fails, falls back to `http://jellynext-placeholder/` URL
- **Prevents "watched" status** - 1-hour duration ensures brief playback interception never reaches Jellyfin's 5% threshold (3 minutes) for marking content as resumable/watched

**Implementation Details**:
- `Resources/dummy.mp4` - Pre-generated minimal MP4 (2x2, 1 hour, h264, CRF 51) embedded in plugin assembly
- Video specs: 2x2 resolution (minimum for H.264 yuv420p), 25fps, ~4.5 kbits/s bitrate
- `VirtualLibraryManager.CreateDummyVideo()` - Extracts embedded resource to plugin data directory
- Extraction process:
  1. Check if `dummy.mp4` already exists in plugin data directory
  2. If not, extract from embedded resources using `Assembly.GetManifestResourceStream()`
  3. Copy stream to file system
  4. Log file size for verification
- No external dependencies (no ffmpeg required)
- Only extracted once (survives plugin reloads)
- Graceful fallback to HTTP URL if extraction fails

**Why This Works**:
- **Real video file** - FFprobe successfully probes valid MP4, returns stream metadata
- **All clients happy** - tvOS/iOS apps no longer crash because FFprobe succeeds
- **Metadata from filename** - Resolver still extracts IDs from filename patterns (TMDB/TVDB IDs in brackets)
- **Playback interception works** - Detects by path containing "jellynext-virtual", not by analyzing file content
- **Minimal size** - Highly compressed 2x2 black video (~2MB for 1 hour)
- **No unwanted tracking** - Since playback stops in <1 second and Jellyfin needs 5% (3 minutes) to mark as resumable, virtual items never show "Resume" or get marked as watched
- **Dummy runtime still set** - Resolver adds `RunTimeTicks = 90 * TimeSpan.TicksPerMinute` for UI display

**Cross-Client Testing**:
- Web UI: ✅ Works (FFprobe succeeds, playback intercepted cleanly)
- iOS/tvOS (Swiftfin): ✅ Fixed - no longer crashes, FFprobe reads dummy video
- Android: ✅ Should work (valid video file, standard FFprobe flow)
- Other clients: ✅ Should work (all use same FFprobe → playback flow)

---