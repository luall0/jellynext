# CLAUDE.md

## Purpose
This file serves as the persistent memory and context store for Claude Code instances working on this repository. It contains critical information about the codebase structure, patterns, conventions, and decisions that must be maintained across sessions.

## How to Update This File

### When to Update
- After implementing new architectural patterns or conventions
- When adding new major features or modules
- After making important technical decisions
- When establishing new coding standards
- After refactoring that changes core structure
- When discovering critical dependencies or constraints

### What to Include
- **Architecture decisions**: Why certain patterns were chosen
- **Code conventions**: Naming, structure, style specific to this project
- **Key abstractions**: Core interfaces, base classes, shared utilities
- **Critical paths**: Authentication, data flow, state management
- **Gotchas**: Non-obvious behaviors, edge cases, pitfalls to avoid
- **Dependencies**: Important libraries and their usage patterns
- **Test strategies**: How to test different parts of the system

### What NOT to Include
- Implementation details that are clear from code
- Temporary TODOs (use code comments instead)
- Change logs (use git history)
- API documentation (use code docs/comments)
- General programming knowledge
- **Test counts or execution times** (these change frequently and provide no useful context)
- **Build commands and scripts** - These live in package.json. Only document non-obvious usage patterns.
- **Metadata footers** - No "Last Updated" dates (use git), version numbers (use package.json), or feature summaries (redundant with content)

### Update Format
Keep updates concise and scannable. Use clear section headers. Focus on context that helps make better decisions faster.

**Balance conciseness with clarity**:
- Prefer bullet points over paragraphs
- Remove obvious information, but keep context that explains "why"
- Show code examples when they clarify non-obvious patterns
- Aim for information density, but prioritize understandability over brevity
- **Keep file/test organization trees** - they help navigate the codebase
- **Keep method signatures and parameters** - they document the API surface
- **Allow some duplication** when it helps understanding (e.g., listing capabilities in overview + detailed sections)

### Git Commit Rules
**NEVER use co-authoring in git commits.** Always commit as the sole author. Do not add "Co-authored-by" trailers to commit messages under any circumstances.

**NEVER add "Generated by Claude Code" or similar attribution** to commit messages. Commit messages should describe the change only, without mentioning AI assistance.

### Code Documentation Rules
**Do not over-document.** Only add comments for:
- Non-obvious business logic or algorithms
- Complex edge cases or gotchas
- Why decisions were made (not what the code does)

Avoid documenting:
- Obvious functionality that's clear from well-named functions/variables
- Redundant type information already in signatures
- What standard library functions do
- Implementation details that are self-explanatory

Good code with clear naming is better than heavily commented code.

**Do not create separate documentation files for features.** Keep documentation minimal and centralized:
- Feature descriptions belong in README.md, kept concise
- Do NOT create individual .md files for each feature or module
- Code should be self-documenting through clear naming and structure
- Only create additional docs if absolutely necessary for complex systems

Avoid documentation sprawl. Less is more.

### Testing and Token Optimization
**IMPORTANT - Token Efficiency**: When running full test suite to verify no breakage, ALWAYS filter output to show only summary:
NEVER run full test output without filtering - console logs consume thousands of tokens unnecessarily.

---

## Project Overview

JellyNext is a Jellyfin plugin that integrates Trakt-powered discovery directly into Jellyfin. It creates per-user virtual libraries for personalized recommendations and new season notifications, with one-click download triggers to Radarr/Sonarr.

**Core capabilities:**
- Per-user Trakt account linking (each Jellyfin user links their own Trakt)
- Virtual libraries: Recommendations and New Seasons (personalized per user)
- One-click downloads via Radarr/Sonarr integration
- Smart Play/Download button switching (shows Play if media exists, Download if not)
- Metadata enrichment via TMDB

## Tech Stack

- **Platform**: C# / .NET 8.0
- **Framework**: Jellyfin Plugin SDK 10.9+
- **External APIs**:
  - Trakt API (OAuth2 for per-user auth)
  - TMDB API (metadata & images)
  - Radarr/Sonarr APIs (download triggers)
- **Code Quality**: StyleCop.Analyzers + jellyfin.ruleset

## Architecture

### Project Structure
```
Jellyfin.Plugin.JellyNext/
├── Configuration/
│   ├── PluginConfiguration.cs   # Global plugin settings
│   └── configPage.html           # Admin web UI (OAuth + config)
├── Api/
│   ├── TraktController.cs        # OAuth endpoints
│   └── JellyNextLibraryController.cs # REST API for virtual library content
├── Services/
│   ├── TraktApi.cs               # Trakt API integration
│   ├── TmdbService.cs            # TMDB API key management (custom or Jellyfin's)
│   ├── ContentCacheService.cs    # In-memory cache for synced content
│   └── ContentSyncService.cs     # Orchestrates syncing across providers
├── Providers/
│   ├── IContentProvider.cs       # Interface for content providers
│   └── RecommendationsProvider.cs # Trakt recommendations implementation
├── Resolvers/
│   └── JellyNextResolver.cs      # IItemResolver for .strm stub files
├── VirtualLibrary/
│   ├── VirtualLibraryManager.cs  # Creates/manages per-user .strm stub files
│   ├── VirtualLibraryCreator.cs  # Initializes virtual library on startup
│   └── VirtualLibraryContentType.cs # Content type enum and helpers
├── ScheduledTasks/
│   └── ContentSyncScheduledTask.cs # Jellyfin scheduled task for syncing
├── Models/
│   ├── TraktUser.cs              # Per-user OAuth storage
│   ├── TraktDeviceCode.cs        # OAuth device flow
│   ├── TraktUserAccessToken.cs   # OAuth tokens
│   ├── TraktUserRefreshTokenRequest.cs
│   ├── TraktMovie.cs             # Trakt movie response
│   ├── TraktShow.cs              # Trakt show response
│   ├── TraktIds.cs               # External IDs (TMDB, IMDB, TVDB, etc)
│   ├── ContentItem.cs            # Unified content representation
│   └── ContentType.cs            # Movie/Show enum
├── Helpers/
│   └── UserHelper.cs             # TraktUser lookup utility
├── Plugin.cs                     # Entry point + IServerApplicationHost
└── PluginServiceRegistrator.cs  # DI service registration
```

### Key Plugin Components
- **Plugin.cs**: Main entry point, inherits `BasePlugin<PluginConfiguration>`, tracks OAuth polling tasks, exposes `IServerApplicationHost`
- **PluginConfiguration**: Stores global settings (Radarr/Sonarr URLs/keys, optional TMDB key, cache expiration, ignore filters, per-user TraktUser array)
- **PluginServiceRegistrator**: Registers all services and content providers in DI container
- **TraktController**: REST endpoints for OAuth (authorize, deauthorize, status check)
- **JellyNextLibraryController**: REST API for accessing virtual library content (recommendations queries)
- **TraktApi**: Handles OAuth device flow, token refresh, authenticated API calls, recommendations fetching
- **TmdbService**: Manages TMDB API key (uses custom if provided, falls back to Jellyfin's via reflection)
- **ContentCacheService**: In-memory per-user, per-provider cache with automatic expiration
- **ContentSyncService**: Orchestrates syncing across all registered `IContentProvider` implementations
- **IContentProvider**: Modular interface for content sources (recommendations, watchlist, trending, etc.)
- **ContentSyncScheduledTask**: Jellyfin scheduled task (configurable in Dashboard), triggers virtual library refresh
- **JellyNextResolver**: IItemResolver that intercepts .strm stub files and converts them to Movie objects with metadata
- **VirtualLibraryManager**: Creates and manages .strm stub files for recommendations in plugin data directory
- **VirtualLibraryCreator**: Initializes virtual library directory on plugin startup

## Key Conventions

### Jellyfin Plugin Standards
- Follow `jellyfin.ruleset` for code analysis (enforced via StyleCop.Analyzers)
- Use XML documentation for public APIs (GenerateDocumentationFile enabled)
- Enable nullable reference types
- Embed web resources (HTML/JS) into assembly

### HTTP Client Usage
- **ALWAYS use `NamedClient.Default`** when creating HTTP clients: `_httpClientFactory.CreateClient(NamedClient.Default)`
- This uses Jellyfin's preconfigured "happy eyeballs" HTTP client
- Required for Trakt API to work (avoids Cloudflare blocks)
- `NamedClient` from `MediaBrowser.Common.Net` namespace

### Trakt API Headers
- **Only two headers required**: `trakt-api-version: 2` and `trakt-api-key: {client_id}`
- Do NOT add User-Agent or Accept headers (causes issues)
- Base URL: `https://api.trakt.tv`
- Endpoints: `/oauth/device/code`, `/oauth/device/token`, `/oauth/token`

### Dependency Injection
- Register services in `PluginServiceRegistrator.cs` implementing `IPluginServiceRegistrator`
- Must register `AddHttpClient()` before services that use `IHttpClientFactory`
- Services auto-discovered by Jellyfin on plugin load
- Content providers registered as `IContentProvider` interface - automatically discovered by `ContentSyncService`

### Per-User Architecture Pattern
- Virtual libraries must be **filtered by current Jellyfin user**
- Each user has their own Trakt OAuth token (stored per-user, not global)
- Item resolution checks user context to return personalized content
- Download triggers use global Radarr/Sonarr credentials but are initiated per-user

### Smart Play/Download Switching
- Before returning virtual item: check if media exists in Jellyfin by TMDB/TVDB ID
- If exists: return real Jellyfin item ID → shows native Play button
- If not exists: return virtual item with `plugin://jellynext/download/{id}` → triggers download on Play
- Works cross-client (Web, iOS, Android, TV, Kodi) via playback interception

## Important Constraints

### Jellyfin Plugin Limitations
- No native "Download" button in clients → use playback interception workaround
- Virtual items must implement proper metadata interfaces to appear correctly
- Embedded resources (HTML/JS) require specific .csproj configuration
- Plugin GUID must be unique and stable: `a4df60c5-6ab4-412a-8f79-2cab93fb2bc5`

### API Rate Limits
- Trakt: respect rate limits (implement caching + scheduled sync)
- TMDB: cache metadata aggressively
- Radarr/Sonarr: minimal calls (only on user-triggered downloads)

### Cross-Client Compatibility
- Must work on all official Jellyfin clients (Web, iOS, Android, TV, Kodi)
- Cannot rely on Web UI-only features for core functionality
- Optional: Web UI JavaScript injection for enhanced UX

### Modular Content Provider System
- **IContentProvider interface**: Extensible contract for content sources
  - `ProviderName`: Unique identifier (e.g., "recommendations", "watchlist")
  - `LibraryName`: Display name for virtual library
  - `FetchContentAsync(userId)`: Fetches content for specific user
  - `IsEnabledForUser(userId)`: Checks if provider enabled for user
- **Easy to add new providers**: Create class implementing `IContentProvider`, register in DI → automatic sync/caching
- **ContentItem model**: Unified representation (movies + shows, all external IDs)
- **ContentSyncService**: Orchestrates syncing across all providers with error isolation
- **ContentCacheService**: Per-user, per-provider in-memory cache with configurable expiration

### TMDB API Key Management
- **Optional configuration**: Users can provide custom TMDB API key (free at themoviedb.org)
- **Automatic fallback**: If no key provided, uses Jellyfin's built-in TMDB key via reflection
- **Benefits of custom key**: Dedicated rate limits, avoids high-traffic metadata issues
- **TmdbService.GetTmdbApiKey()**: Handles custom key priority + reflection fallback with caching

## Implemented Features

### ✅ Per-User Trakt OAuth (Device Flow)
**Architecture:**
- Trakt Client ID/Secret embedded in `TraktApi.cs` (not in config)
- Per-user OAuth tokens stored in `PluginConfiguration.TraktUsers[]` array
- Each `TraktUser` has: `AccessToken`, `RefreshToken`, `LinkedMbUserId`, `AccessTokenExpiration`

**OAuth Device Flow:**
1. Admin selects Jellyfin user in plugin config page
2. Click "Link Trakt Account" → `POST /JellyNext/Trakt/Users/{userGuid}/Authorize`
3. Backend requests device code from Trakt API
4. Frontend displays user code + trakt.tv/activate link
5. Background polling task checks authorization every 3 seconds
6. On success: stores access/refresh tokens in `TraktUser`, saves config
7. Frontend auto-detects completion and shows success

**Automatic Token Refresh:**
- Tokens expire with 75% safety buffer (`ExpirationWithBuffer`)
- `EnsureValidAccessToken()` checks expiration before every API call
- `RefreshUserAccessToken()` exchanges refresh token for new access token
- Trakt rotates refresh tokens on each refresh (new tokens saved automatically)

**Key Methods:**
- `TraktApi.AuthorizeDevice(traktUser)` - Initiates device flow
- `TraktApi.PollForAccessToken(deviceCode, traktUser)` - Background polling
- `TraktApi.RefreshUserAccessToken(traktUser)` - Token refresh
- `TraktApi.CreateTraktClient(traktUser)` - Creates authenticated HTTP client with auto-refresh
- `UserHelper.GetTraktUser(userGuid)` - Lookup TraktUser by Jellyfin user ID

**API Endpoints:**
- `POST /JellyNext/Trakt/Users/{userGuid}/Authorize` - Start OAuth
- `GET /JellyNext/Trakt/Users/{userGuid}/AuthorizationStatus` - Check status
- `POST /JellyNext/Trakt/Users/{userGuid}/Deauthorize` - Revoke access

### ✅ Trakt Recommendations API
**Endpoints:**
- `TraktApi.GetMovieRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized movie recommendations
- `TraktApi.GetShowRecommendations(traktUser, ignoreCollected, ignoreWatchlisted, limit)` - Fetches personalized show recommendations

**Configuration:**
- `IgnoreCollected` (default: true) - Filter out items in user's Trakt collection
- `IgnoreWatchlisted` (default: false) - Filter out items in user's watchlist
- Both configurable via plugin settings page

**Implementation:**
- Returns `TraktMovie[]` and `TraktShow[]` with IDs (Trakt, TMDB, IMDB, TVDB)
- Automatic token refresh before API calls
- Error handling with empty array fallback

### ✅ Modular Content Sync System
**Architecture:**
- `ContentSyncScheduledTask` - Jellyfin scheduled task (appears in Dashboard → Scheduled Tasks)
- Default trigger: every 6 hours (user-configurable in Dashboard)
- `ContentSyncService.SyncAllAsync()` - Syncs all users across all registered providers
- Per-provider error isolation - one failure doesn't break entire sync

**Caching:**
- `ContentCacheService` - In-memory cache per user per provider
- `CacheExpirationHours` config (default: 6 hours) - Controls data freshness
- Cache serves instant results for virtual library browsing
- Protects against Trakt API rate limits

**Current Providers:**
- `RecommendationsProvider` - Fetches movie + show recommendations (up to 50 each)

### ✅ Per-User Native Virtual Libraries
**Architecture:**
- Creates Jellyfin-native virtual libraries that work in all clients without custom UI
- **Per-user isolation**: Each user has their own directory with personalized recommendations
- Uses .strm stub files as a bridge between cached recommendations and Jellyfin's item system
- Full metadata resolution via TMDB provider IDs (posters, descriptions, cast)

**Directory Structure:**
- **Base**: `<plugin-data>/jellynext-virtual/`
- **Per-user format**: `jellynext-virtual/[userId]/[content-type]/`
- **Example**: `jellynext-virtual/12345678-1234-1234-1234-123456789012/movies_recommendations/`
- **Content types**: `movies_recommendations`, `shows_recommendations`, `watchlist_movies`, `watchlist_shows`
- **Scalable**: Easy to add new content types (trending, calendar, etc.)

**Content Type System:**
- `VirtualLibraryContentType` enum defines available content types
- `VirtualLibraryContentTypeHelper` provides standardized naming/mapping:
  - `GetDirectoryName()`: "movies_recommendations"
  - `GetProviderName()`: "recommendations"
  - `GetDisplayName()`: "Movie Recommendations"
  - `GetMediaType()`: "Movies" or "Shows"
  - `TryParseDirectoryName()`: Parse directory name back to enum

**Stub File System:**
- **Format**: `Title (Year) [tmdbid-ID].strm` (e.g., `Thor (2011) [tmdbid-10195].strm`)
- **Content**: `plugin://jellynext/movie/{tmdbId}` URL (not currently used but standard format)
- **Why .strm**: Jellyfin recognizes .strm as streaming content and skips FFprobe (prevents errors)
- **Isolation**: Each user's files in separate directory, no cross-user data leakage

**Resolver Integration:**
- `JellyNextResolver` implements `IItemResolver` with `ResolverPriority.Plugin`
- Intercepts .strm files in `jellynext-virtual` folder during library scans
- Extracts **userId** and **content type** from path using regex: `@"jellynext-virtual[/\\]([a-f0-9-]+)[/\\]([^/\\]+)[/\\]"`
- Extracts TMDB ID from filename using regex: `\[tmdbid-(\d+)\]$`
- Looks up movie details in ContentCacheService **for specific user**
- Creates Movie object with proper metadata and provider IDs
- Sets TMDB/IMDB ProviderIds for metadata lookup by Jellyfin's metadata providers

**Automatic Sync:**
- `VirtualLibraryManager.RefreshStubFiles()` syncs **all users** (not just admin)
- `VirtualLibraryManager.RefreshStubFilesForUser(userId, contentType)` syncs specific user/type
- Creates new .strm files for new recommendations
- Removes old .strm files for removed recommendations
- File naming includes title/year for human readability and proper Jellyfin parsing
- Per-user directories created automatically on first sync

**Migration from Single-User:**
- `MigrateOldStructure()` detects old .strm files in root directory
- Automatically deletes old files on first run after upgrade
- Logs migration progress
- New per-user structure created cleanly

**Library Organization:**
- **One library per content type per user** (not one library per user!)
- Example for one user:
  - Library 1: "admin's Movies Recommendations" → `jellynext-virtual/[userId]/movies_recommendations/`
  - Library 2: "admin's Shows Recommendations" → `jellynext-virtual/[userId]/shows_recommendations/`
  - Library 3: "admin's Movie Watchlist" → `jellynext-virtual/[userId]/watchlist_movies/`
- This allows granular control and better organization in Jellyfin UI
- Each library can have different visibility/permissions

**Setup Process:**
1. Plugin creates `jellynext-virtual` base directory on startup
2. Logs per-user, per-content-type setup instructions with exact paths
3. Sync task populates per-user, per-content-type directories with .strm stub files
4. Admin creates SEPARATE library for EACH content type:
   - Add "admin's Movies Recommendations" → Movies library → `jellynext-virtual/[userId]/movies_recommendations/`
   - Add "admin's Shows Recommendations" → Shows library → `jellynext-virtual/[userId]/shows_recommendations/`
   - (Repeat for each user and content type)
5. Jellyfin scans each library independently
6. Resolver converts stubs to Movie/Show objects with user context
7. Metadata providers fetch posters/info using TMDB IDs
8. Content appears in respective libraries with full metadata

**Current Implementation:**
- ✅ Full per-user isolation
- ✅ Movies recommendations support
- ✅ Shows recommendations support
- ⏳ Watchlist support (future: new content provider)

## Core Workflows

### Initial Setup (Admin)
1. Admin configures plugin via Jellyfin Dashboard
2. (Optional) Enter custom TMDB API key (uses Jellyfin's key if not provided)
3. Enter Radarr/Sonarr URLs + API keys
4. Configure recommendation filters (ignore collected/watchlisted)
5. Set cache expiration (default: 6 hours)
6. Configure sync schedule in Dashboard → Scheduled Tasks → "Sync Trakt Content"

### User Trakt Linking (Per-User)
1. Admin opens plugin config → selects Jellyfin user from dropdown
2. Clicks "Link Trakt Account" → receives user code
3. User visits trakt.tv/activate and enters code
4. Plugin auto-detects authorization completion
5. Tokens stored in `PluginConfiguration.TraktUsers[]` for that user

### Virtual Library Display
1. User opens specific library (e.g., "admin's Movies Recommendations")
2. Plugin resolves .strm files, extracting userId and content type from path
3. Fetches that user's cached content for that specific content type
4. For each item: check if exists in Jellyfin by TMDB ID
5. Return existing item ID (Play) or virtual item (Download)
6. Enrich with TMDB metadata (poster, description)

### Download Trigger
1. User clicks Play on virtual item with `plugin://` path
2. Plugin intercepts playback request
3. Parse TMDB ID from URL
4. Call Radarr/Sonarr API to add media
5. Show notification to user (download initiated)

## Important Gotchas

### Trakt API OAuth
- **Cloudflare Protection**: Trakt API is behind Cloudflare - must use `NamedClient.Default` HTTP client
- **No Custom Headers**: Only use `trakt-api-version` and `trakt-api-key` headers (User-Agent/Accept cause blocks)
- **Token Safety Buffer**: Use 75% of token lifetime before refresh to prevent race conditions
- **Refresh Token Rotation**: Trakt rotates refresh tokens on each refresh - always save new tokens
- **Background Polling**: OAuth device flow polls in background - track with `Plugin.Instance.PollingTasks` dictionary

### Configuration Access
- Use `Plugin.Instance?.Configuration` not `Plugin.Instance?.PluginConfiguration`
- `BasePlugin<T>` exposes config as `Configuration` property
- `UserHelper.GetTraktUser(userGuid)` is the standard way to lookup per-user tokens

### TMDB API Key Access
- **TmdbService** handles TMDB API key with intelligent fallback
- Custom key from config is prioritized
- Fallback uses reflection to access Jellyfin's TMDB plugin configuration
- Reflection path: `IServerApplicationHost` → `PluginManager` → `TmdbPlugin` → `Configuration.TmdbApiKey`
- Cached after first reflection lookup for performance

### Content Sync Architecture
- **Scheduled task** (`ContentSyncScheduledTask`) registered with Jellyfin's task manager
- `GetDefaultTriggers()` sets initial 6-hour interval (user can change in Dashboard)
- **Cache expiration** is separate from sync schedule (prevents indefinitely stale data)
- Cache serves instant responses when browsing virtual libraries
- Sync refreshes cache on schedule or manual trigger

### Virtual Library Stub Files (Per-User Architecture)
- **Must use .strm extension**: Jellyfin recognizes .strm as streaming content and skips FFprobe
- **Different structures for movies vs shows**:
  - **Movies**: Flat .strm files in root directory
    - Format: `Title (Year) [tmdbid-ID].strm`
    - Example: `Thor (2011) [tmdbid-10195].strm`
    - Resolved by: `ResolveStubFile()` method
  - **Shows**: Folder structure (Jellyfin expects TV shows in folders)
    - Format: `Title (Year) [tvdbid-ID]/tvshow.strm`
    - Example: `Black Mirror (2011) [tvdbid-253463]/tvshow.strm`
    - Resolved by: `ResolveShowFolder()` method - detects directories with `[tvdbid-XXX]` pattern
- **Title/Year parsing**: Jellyfin's metadata providers parse title and year from filename/folder name before using provider IDs
- **Path structure**: `jellynext-virtual/[userId]/[content-type]/` for per-user isolation
- **Regex extraction**: Resolver uses patterns:
  - Path: `@"jellynext-virtual[/\\]([a-f0-9-]+)[/\\]([^/\\]+)[/\\]"` to extract userId and content type
  - Movie filename: `\[tmdbid-(\d+)\]$` to extract TMDB ID
  - Show folder name: `\[tvdbid-(\d+)\]$` to extract TVDB ID
- **Sanitize filenames**: Remove invalid characters from titles (replace with underscore)
- **Per-user library setup**: Each user needs separate library pointing to their directory (e.g., `jellynext-virtual/[userId]/movies_recommendations` or `jellynext-virtual/[userId]/shows_recommendations`)
- **Resolver specificity**: Only intercepts paths containing `jellynext-virtual` (avoids interfering with other content)
- **Provider IDs essential**:
  - Movies: Must set TMDB and IMDB ProviderIds on Movie object for metadata to resolve
  - Shows: Must set TVDB (primary), TMDB, and IMDB ProviderIds on Series object for metadata to resolve
- **User context**: Resolver looks up content in cache using extracted userId - ensures each user sees only their recommendations
- **Content type mapping**: Directory name (e.g., `movies_recommendations` or `shows_recommendations`) maps to provider name (e.g., `recommendations`) via `VirtualLibraryContentTypeHelper`

---