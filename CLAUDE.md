# CLAUDE.md

## Purpose
This file serves as the persistent memory and context store for Claude Code instances working on this repository. It contains critical information about the codebase structure, patterns, conventions, and decisions that must be maintained across sessions.

## How to Update This File

### When to Update
- After implementing new architectural patterns or conventions
- When adding new major features or modules
- After making important technical decisions
- When establishing new coding standards
- After refactoring that changes core structure
- When discovering critical dependencies or constraints

### What to Include
- **Architecture decisions**: Why certain patterns were chosen
- **Code conventions**: Naming, structure, style specific to this project
- **Key abstractions**: Core interfaces, base classes, shared utilities
- **Critical paths**: Authentication, data flow, state management
- **Gotchas**: Non-obvious behaviors, edge cases, pitfalls to avoid
- **Dependencies**: Important libraries and their usage patterns
- **Test strategies**: How to test different parts of the system

### What NOT to Include
- Implementation details that are clear from code
- Temporary TODOs (use code comments instead)
- Change logs (use git history)
- API documentation (use code docs/comments)
- General programming knowledge
- **Test counts or execution times** (these change frequently and provide no useful context)
- **Build commands and scripts** - These live in package.json. Only document non-obvious usage patterns.
- **Metadata footers** - No "Last Updated" dates (use git), version numbers (use package.json), or feature summaries (redundant with content)

### Update Format
Keep updates concise and scannable. Use clear section headers. Focus on context that helps make better decisions faster.

**Balance conciseness with clarity**:
- Prefer bullet points over paragraphs
- Remove obvious information, but keep context that explains "why"
- Show code examples when they clarify non-obvious patterns
- Aim for information density, but prioritize understandability over brevity
- **Keep file/test organization trees** - they help navigate the codebase
- **Keep method signatures and parameters** - they document the API surface
- **Allow some duplication** when it helps understanding (e.g., listing capabilities in overview + detailed sections)

### Git Commit Rules
**NEVER use co-authoring in git commits.** Always commit as the sole author. Do not add "Co-authored-by" trailers to commit messages under any circumstances.

**NEVER add "Generated by Claude Code" or similar attribution** to commit messages. Commit messages should describe the change only, without mentioning AI assistance.

### Code Documentation Rules
**Do not over-document.** Only add comments for:
- Non-obvious business logic or algorithms
- Complex edge cases or gotchas
- Why decisions were made (not what the code does)

Avoid documenting:
- Obvious functionality that's clear from well-named functions/variables
- Redundant type information already in signatures
- What standard library functions do
- Implementation details that are self-explanatory

Good code with clear naming is better than heavily commented code.

**Do not create separate documentation files for features.** Keep documentation minimal and centralized:
- Feature descriptions belong in README.md, kept concise
- Do NOT create individual .md files for each feature or module
- Code should be self-documenting through clear naming and structure
- Only create additional docs if absolutely necessary for complex systems

Avoid documentation sprawl. Less is more.

### Testing and Token Optimization
**IMPORTANT - Token Efficiency**: When running full test suite to verify no breakage, ALWAYS filter output to show only summary:
NEVER run full test output without filtering - console logs consume thousands of tokens unnecessarily.

---

## Project Overview

JellyNext is a Jellyfin plugin that integrates Trakt-powered discovery directly into Jellyfin. It creates per-user virtual libraries for personalized recommendations and new season notifications, with one-click download triggers to Radarr/Sonarr.

**Core capabilities:**
- Per-user Trakt account linking (each Jellyfin user links their own Trakt)
- Virtual libraries: Recommendations and New Seasons (personalized per user)
- One-click downloads via Radarr/Sonarr integration
- Smart Play/Download button switching (shows Play if media exists, Download if not)
- Metadata enrichment via TMDB

## Tech Stack

- **Platform**: C# / .NET 8.0
- **Framework**: Jellyfin Plugin SDK 10.9+
- **External APIs**:
  - Trakt API (OAuth2 for per-user auth)
  - TMDB API (metadata & images)
  - Radarr/Sonarr APIs (download triggers)
- **Code Quality**: StyleCop.Analyzers + jellyfin.ruleset

## Architecture

### Project Structure
```
Jellyfin.Plugin.JellyNext/
├── Configuration/
│   ├── PluginConfiguration.cs   # Global plugin settings
│   └── configPage.html           # Admin web UI (OAuth + config)
├── Api/
│   └── TraktController.cs        # OAuth endpoints
├── Services/
│   └── TraktApi.cs               # Trakt API integration
├── Models/
│   ├── TraktUser.cs              # Per-user OAuth storage
│   ├── TraktDeviceCode.cs        # OAuth device flow
│   ├── TraktUserAccessToken.cs   # OAuth tokens
│   └── TraktUserRefreshTokenRequest.cs
├── Helpers/
│   └── UserHelper.cs             # TraktUser lookup utility
├── Plugin.cs                     # Entry point + polling tasks
└── PluginServiceRegistrator.cs  # DI service registration
```

### Key Plugin Components
- **Plugin.cs**: Main entry point, inherits `BasePlugin<PluginConfiguration>`, tracks OAuth polling tasks
- **PluginConfiguration**: Stores global settings (Radarr/Sonarr URLs/keys, TMDB key, sync interval, per-user TraktUser array)
- **PluginServiceRegistrator**: Registers TraktApi and HttpClient in DI container
- **TraktController**: REST endpoints for OAuth (authorize, deauthorize, status check)
- **TraktApi**: Handles OAuth device flow, token refresh, authenticated API calls
- **TraktUser**: Per-user OAuth tokens + preferences (stored in PluginConfiguration.TraktUsers array)

## Key Conventions

### Jellyfin Plugin Standards
- Follow `jellyfin.ruleset` for code analysis (enforced via StyleCop.Analyzers)
- Use XML documentation for public APIs (GenerateDocumentationFile enabled)
- Enable nullable reference types
- Embed web resources (HTML/JS) into assembly

### HTTP Client Usage
- **ALWAYS use `NamedClient.Default`** when creating HTTP clients: `_httpClientFactory.CreateClient(NamedClient.Default)`
- This uses Jellyfin's preconfigured "happy eyeballs" HTTP client
- Required for Trakt API to work (avoids Cloudflare blocks)
- `NamedClient` from `MediaBrowser.Common.Net` namespace

### Trakt API Headers
- **Only two headers required**: `trakt-api-version: 2` and `trakt-api-key: {client_id}`
- Do NOT add User-Agent or Accept headers (causes issues)
- Base URL: `https://api.trakt.tv`
- Endpoints: `/oauth/device/code`, `/oauth/device/token`, `/oauth/token`

### Dependency Injection
- Register services in `PluginServiceRegistrator.cs` implementing `IPluginServiceRegistrator`
- Must register `AddHttpClient()` before services that use `IHttpClientFactory`
- Services auto-discovered by Jellyfin on plugin load

### Per-User Architecture Pattern
- Virtual libraries must be **filtered by current Jellyfin user**
- Each user has their own Trakt OAuth token (stored per-user, not global)
- Item resolution checks user context to return personalized content
- Download triggers use global Radarr/Sonarr credentials but are initiated per-user

### Smart Play/Download Switching
- Before returning virtual item: check if media exists in Jellyfin by TMDB/TVDB ID
- If exists: return real Jellyfin item ID → shows native Play button
- If not exists: return virtual item with `plugin://jellynext/download/{id}` → triggers download on Play
- Works cross-client (Web, iOS, Android, TV, Kodi) via playback interception

## Important Constraints

### Jellyfin Plugin Limitations
- No native "Download" button in clients → use playback interception workaround
- Virtual items must implement proper metadata interfaces to appear correctly
- Embedded resources (HTML/JS) require specific .csproj configuration
- Plugin GUID must be unique and stable: `a4df60c5-6ab4-412a-8f79-2cab93fb2bc5`

### API Rate Limits
- Trakt: respect rate limits (implement caching + scheduled sync)
- TMDB: cache metadata aggressively
- Radarr/Sonarr: minimal calls (only on user-triggered downloads)

### Cross-Client Compatibility
- Must work on all official Jellyfin clients (Web, iOS, Android, TV, Kodi)
- Cannot rely on Web UI-only features for core functionality
- Optional: Web UI JavaScript injection for enhanced UX

## Implemented Features

### ✅ Per-User Trakt OAuth (Device Flow)
**Architecture:**
- Trakt Client ID/Secret embedded in `TraktApi.cs` (not in config)
- Per-user OAuth tokens stored in `PluginConfiguration.TraktUsers[]` array
- Each `TraktUser` has: `AccessToken`, `RefreshToken`, `LinkedMbUserId`, `AccessTokenExpiration`

**OAuth Device Flow:**
1. Admin selects Jellyfin user in plugin config page
2. Click "Link Trakt Account" → `POST /JellyNext/Trakt/Users/{userGuid}/Authorize`
3. Backend requests device code from Trakt API
4. Frontend displays user code + trakt.tv/activate link
5. Background polling task checks authorization every 3 seconds
6. On success: stores access/refresh tokens in `TraktUser`, saves config
7. Frontend auto-detects completion and shows success

**Automatic Token Refresh:**
- Tokens expire with 75% safety buffer (`ExpirationWithBuffer`)
- `EnsureValidAccessToken()` checks expiration before every API call
- `RefreshUserAccessToken()` exchanges refresh token for new access token
- Trakt rotates refresh tokens on each refresh (new tokens saved automatically)

**Key Methods:**
- `TraktApi.AuthorizeDevice(traktUser)` - Initiates device flow
- `TraktApi.PollForAccessToken(deviceCode, traktUser)` - Background polling
- `TraktApi.RefreshUserAccessToken(traktUser)` - Token refresh
- `TraktApi.CreateTraktClient(traktUser)` - Creates authenticated HTTP client with auto-refresh
- `UserHelper.GetTraktUser(userGuid)` - Lookup TraktUser by Jellyfin user ID

**API Endpoints:**
- `POST /JellyNext/Trakt/Users/{userGuid}/Authorize` - Start OAuth
- `GET /JellyNext/Trakt/Users/{userGuid}/AuthorizationStatus` - Check status
- `POST /JellyNext/Trakt/Users/{userGuid}/Deauthorize` - Revoke access

## Core Workflows

### Initial Setup (Admin)
1. Admin configures plugin via Jellyfin Dashboard
2. Enter TMDB API key
3. Enter Radarr/Sonarr URLs + API keys
4. Set sync interval (default: 6 hours)

### User Trakt Linking (Per-User)
1. Admin opens plugin config → selects Jellyfin user from dropdown
2. Clicks "Link Trakt Account" → receives user code
3. User visits trakt.tv/activate and enters code
4. Plugin auto-detects authorization completion
5. Tokens stored in `PluginConfiguration.TraktUsers[]` for that user

### Virtual Library Display
1. User opens "Trakt Recommendations" or "New Seasons" library
2. Plugin fetches user's Trakt data (cached)
3. For each item: check if exists in Jellyfin by TMDB ID
4. Return existing item ID (Play) or virtual item (Download)
5. Enrich with TMDB metadata (poster, description)

### Download Trigger
1. User clicks Play on virtual item with `plugin://` path
2. Plugin intercepts playback request
3. Parse TMDB ID from URL
4. Call Radarr/Sonarr API to add media
5. Show notification to user (download initiated)

## Important Gotchas

### Trakt API OAuth
- **Cloudflare Protection**: Trakt API is behind Cloudflare - must use `NamedClient.Default` HTTP client
- **No Custom Headers**: Only use `trakt-api-version` and `trakt-api-key` headers (User-Agent/Accept cause blocks)
- **Token Safety Buffer**: Use 75% of token lifetime before refresh to prevent race conditions
- **Refresh Token Rotation**: Trakt rotates refresh tokens on each refresh - always save new tokens
- **Background Polling**: OAuth device flow polls in background - track with `Plugin.Instance.PollingTasks` dictionary

### Configuration Access
- Use `Plugin.Instance?.Configuration` not `Plugin.Instance?.PluginConfiguration`
- `BasePlugin<T>` exposes config as `Configuration` property
- `UserHelper.GetTraktUser(userGuid)` is the standard way to lookup per-user tokens

---